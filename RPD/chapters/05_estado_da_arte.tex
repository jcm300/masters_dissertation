\section{JavaScript e a Programação Assíncrona}
A linguagem \textit{JavaScript} teve a sua origem no \textit{browser} \textit{Netscape Navigator} como uma forma de adicionar programas a páginas web.~\cite{elojs} Hoje em dia é usado por grande parte dos \textit{browsers} e tornou possível as aplicações web onde o utilizador pode interagir sem precisar de realizar \textit{refresh} ao fim de cada ação.
Contudo o \textit{Javascript} é bastante liberal no que permite o programador escrever, facilitando a aprendizagem para novos programadores mas tornando a tarefa de resolver e encontrar problemas bem mais difícil visto não apontar aonde estão esses problemas. Ainda assim esta flexibilidade permite uma quantidade de técnicas que não são possíveis em linguagens mais rígidas e que permitem ultrapassar algumas falhas do \textit{Javascript}.~\cite{elojs} 

\subsection{Programação Assíncrona}
Muitos programas em \textit{JavaScript} precisam de por exemplo obter dados através da rede ou a partir do disco. Estes casos são muito mais lentos do que obter os dados a partir de memória para posterior processamento pelo processador. Na realização de tais pedidos o programa em \textit{Javascript} perderia o acesso ao processador, passando este acesso para outro programa que esteja a correr. Só depois de receber o sinal de que o pedido foi efetuado e de ter de novo acesso ao processador é que o programa voltaria a continuar o seu trabalho.

Por forma a evitar perder o acesso do processador em tais casos, e assim realizar trabalho enquanto se espera pela resposta do pedido, o \textit{Javascript} segue um modelo assíncrono. O modelo assíncrono permite que aconteçam várias coisas ao mesmo tempo; quando começa um pedido o programa continua a correr; quando o pedido termina, o programa é informado e tem acesso ao resultado.~\cite{elojs} Para além de não se perder imediatamente o acesso ao processor, o uso de programação assíncrona permite receber e enviar dados de e para múltiplos dispositivos ao mesmo tempo sem complicar a gestão de \textit{threads} e a sincronização necessária em tais casos. Ao usar um modelo assíncrono a expressão de programas que não seguem um modelo de controlo linear é mais fácil enquanto que torna mais difícil aqueles que o seguem.~\cite{elojs}

\subsubsection{\textit{Callbacks}}
Uma abordagem de programação assíncrona é a adição de um argumento extra, uma função \textit{callback}, nas funções que realizam pedidos lentos.~\cite{elojs} Quando o pedido concluir a função \textit{callback} será chamada tendo como argumento o resultado do pedido. Com o uso de callbacks o nível de indentação aumenta com cada pedido assíncrono o que em alguns casos pode tornar o código um pouco difícil de compreender, principalmente nos casos com múltiplos pedidos assíncronos seguidos que têm de ser sequenciais. Para além disso, qualquer função que chame uma função assíncrona tem de ser ela própria assíncrona. Não é recomendado a reestruturação de grandes quantidades de código através de \textit{callbacks} visto ser mais propenso a erros do que retornar apenas um valor.

\begin{lstlisting}[language=JavaScript, caption=Exemplo de uma \textit{Callback}]
    almocar("comida", function(dentes%*\_*)sujos)%*\{*)
        dentes%*\_*)limpos = lavar%*\_*)dentes(dentes%*\_*)sujos)
    %*\}*))
\end{lstlisting}

\subsubsection{Promessas}
Uma outra abordagem, em vez de passar uma função a ser chamada no futuro, é devolver um objeto que represente este evento futuro, uma promessa. Ou seja, uma promessa é um pedido assíncrono que pode ser concluído no futuro e produzir um valor, tendo a capacidade de notificar qualquer interessado quando o valor estiver disponível.\cite{elojs} O resultado de uma promessa tanto pode já estar pronto ou estar apenas daqui a algum tempo. A principal vantagem das promessas é que simplificam o uso de funções assíncronas visto que não é necessário passar uma função \textit{callback}. Como tal estas funções são similares às restantes mas com uma pequena diferença, o resultado da função pode ainda não estar disponível. 

\begin{lstlisting}[language=JavaScript, caption=Exemplo de uma Promessa]
    almocar("comida")
        .then(dentes%*\_*)sujos =%*$>$*) dentes%*\_*)limpos = lavar%*\_*)dentes(dentes%*\_*)sujos))
\end{lstlisting}

\subsubsection{Exceções}
Durante a execução de um pedido assíncrono podem ocorrer exceções seja por um erro ou porque por exemplo ocorreu um \textit{time out} do pedido, este último acontece essencialmente quando se realiza pedidos através da rede. Estas exceções precisam de ser tratadas por forma a que o programa que estámos a desenvolver não ``expluda'' deixando de funcionar. Esta tratamento não é simples de se realizar quando se usa \textit{callbacks} enquanto que no caso das promessas basta o uso de um \textit{catch}. No caso das \textit{callbacks} o pedido assíncrono teria de devolver dois valores em vez de um, o primeiro com o erro em caso de insucesso e o segundo com o resultado em caso de sucesso o que obrigaria a função \textit{callback} a verificar se não recebeu uma exceção.

\begin{lstlisting}[language=JavaScript, caption=Exemplo de uma \textit{Callback} com captura de exceções]
    almocar("comida", function(erro, dentes%*\_*)sujos)%*\{*)
        if(!erro)%*\{*)
            dentes%*\_*)limpos = lavar%*\_*)dentes(dentes%*\_*)sujos)
        %*\}*)else%*\{*)
            console.log("Falta pasta de dentes")
        %*\}*)
    %*\}*))
\end{lstlisting}

\begin{lstlisting}[language=JavaScript, caption=Exemplo de uma Promessa com captura das exceções]
    almocar("comida")
        .then(dentes%*\_*)sujos =%*$>$*) dentes%*\_*)limpos = lavar%*\_*)dentes(dentes%*\_*)sujos))
        .catch(erro =%*$>$*) console.log("Falta pasta de dentes"))
\end{lstlisting}

\subsubsection{Funções \textit{async}}
Dentro de funções \textit{async} é possível escrever código pseudo-síncrono por forma a descrever código assíncrono com recurso ao \textit{await} que espera pela conclusão de uma promessa antes de avançar com a execução do resto da função, ficando o código com um aspeto semelhante ao síncrono. As funções \textit{async} retornam implicitamente uma promessa e enquanto estão à espera duma promessa (\textit{await}) ficam congeladas. Serão resumidas mais tarde quando a promessa estiver concluída.

\begin{lstlisting}[language=JavaScript, caption=Exemplo de uma função \textit{async}]
    async function almoco()%*\{*)
        try%*\{*)
            dentes%*\_*)sujos = await almocar("comida")
            dentes%*\_*)limpos = lavar%*\_*)dentes(dentes%*\_*)sujos)
        %*\}*)catch(erro)%*\{*)
            console.log("Falta pasta de dentes")
        %*\}*)
        return "Almocei!"
    %*\}*)
\end{lstlisting}

\section{Node.js}
\textit{Node.js} é um ambiente de execução que permite usar \textit{JavaScript} fora do contexto de um \textit{browser} permitindo construir desde ferramentas de linha de comandos até servidores \acrshort{http}. Foi originalmente desenhado de forma a ter o papel de nodo numa rede. O \textit{JavaScript} não tem embutido a capacidade de entrada e saída de dados sendo suprimida esta necessidade com o uso do \textit{Node.js}.

Quando instalado num sistema, o \textit{Node.js} permite executar ficheiros \textit{JavaScript} através do comando \texttt{node}. Se este comando for executado sem indicar um ficheiro apresenta uma consola interativa onde se pode introduzir código \textit{JavaScript}, executá-lo e obter o resultado.

Através do \acrshort{npm}, mais precisamente do comando \texttt{npm}, é possível instalar, no nosso projeto pessoal, os módulos \textit{JavaScript} disponíveis no repositório \textit{online}. Caso exista um ficheiro \textit{package.json} no projeto é mantido neste os módulos já instalados e as suas versões bem como meta informação do projeto.

Em \textit{Node.js} estão disponíveis os \textit{bindings} globais \texttt{process} e \texttt{console} que permitem inspecionar e manipular o programa atual. Para além destes, também estão diponíveis os \textit{bindings} padrão do \textit{JavaScript} exceto aqueles relacionados com funcionalidades do \textit{browser}, como o \texttt{document}.

O \textit{Node.js} tem algums módulos embutidos, entre os quais o módulo \texttt{fs} (\textit{file system}) que exporta funções que permitem trabalhar com ficheiros e directorias. Tem também o módulo \texttt{http} que exporta funções que permitem correr servidores \acrshort{http} ou fazer pedidos \acrshort{http}.

Todo o input e output no \textit{Node.js} é realizado de forma assíncrona a menos que se use uma variante síncrona de uma determinada função.~\cite{elojs}

\section{\acrshort{rest}}
\cite{restws}

\section{express}
\cite{wdmongo}
%procurar "semelhantes" para cada um

\section{passport}
%procurar "semelhantes" para cada um

\section{jsonwebtoken}
%package e conceito JWT
%procurar "semelhantes" para cada um

\section{passport-jwt}
%procurar "semelhantes" para cada um

\section{CORS}
%falar da package e do conceito CORS
%procurar "semelhantes" para cada um

\section{axios}
%procurar "semelhantes" para cada um

\section{HTTP Status}

\section{Headers do HTTP}

\section{Autenticação.gov}
\cite{agov}

\section{exceljs}
%procurar "semelhantes" para cada um

\section{MongoDB}
\cite{wdmongo}

\section{mongoose}
%procurar "semelhantes" para cada um

\section{Web Semântica}
\cite{lsparql}

\subsection{RDF}
\cite{lsparql}

\subsection{SPARQL}
\cite{lsparql}

%se calhar referir algumas packages de ligação ao sparql em vez de usar o que criei

\section{GraphDB}
%procurar "semelhantes" para cada um (Neo4j)

\section{Swagger}
%procurar "semelhantes" para cada um

\section{Swagger-UI}

\section{yaml-include}
%procurar "semelhantes" para cada um

\section{swagger-ui-express}
%procurar "semelhantes" para cada um

\section{js-yaml}
%procurar "semelhantes" para cada um

\section{Nginx}
\cite{nginxcook}
%procurar "semelhantes" para cada um

\section{Ontologia}
\cite{bontology}
%conceito

\section{Docker}
\cite{udocker}
%procurar "semelhantes" para cada um

\section{Docker Compose}
\cite{udocker}
%procurar "semelhantes" para cada um

\section{Lista Consolidada}

\section{Tabelas de Seleção}

\section{Cache e Fecho Transitivo}
