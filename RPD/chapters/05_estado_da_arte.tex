\section{JavaScript e a Programação Assíncrona}
A linguagem \textit{JavaScript} teve a sua origem no \textit{browser} \textit{Netscape Navigator} como uma forma de adicionar programas a páginas web.~\cite{elojs} Hoje em dia é usado por grande parte dos \textit{browsers} e tornou possível as aplicações web onde o utilizador pode interagir sem precisar de realizar \textit{refresh} ao fim de cada ação.
Contudo o \textit{Javascript} é bastante liberal no que permite o programador escrever, facilitando a aprendizagem para novos programadores mas tornando a tarefa de resolver e encontrar problemas bem mais difícil visto não apontar aonde estão esses problemas. Ainda assim esta flexibilidade permite uma quantidade de técnicas que não são possíveis em linguagens mais rígidas e que permitem ultrapassar algumas falhas do \textit{Javascript}.~\cite{elojs} 

\subsection{Programação Assíncrona}
Muitos programas em \textit{JavaScript} precisam de por exemplo obter dados através da rede ou a partir do disco. Estes casos são muito mais lentos do que obter os dados a partir de memória para posterior processamento pelo processador. Na realização de tais pedidos o programa em \textit{Javascript} perderia o acesso ao processador, passando este acesso para outro programa que esteja a correr. Para além disso o programa em \textit{Javascript} passaria para a lista de bloqueado do processador enquanto estivesse à espera do pedido e quando recebesse o sinal de que o pedido foi realizado passaria para a lista de espera antes de ter de novo acesso ao processador e assim continuar com o seu trabalho.

Por forma evitar perder o acesso do processador em tais casos, e assim realizar trabalho enquanto se espera pela resposta do pedido, o \textit{Javascript} segue um modelo assíncrono. O modelo assíncrono permite que aconteçam várias coisas ao mesmo tempo; quando começa um pedido o programa continua a correr; quando o pedido termina, o programa é informado e tem acesso ao resultado.~\cite{elojs} Ao usar um modelo assíncrono a expressão de programas que não seguem um modelo de controlo linear é mais fácil enquanto que torna mais difícil aqueles que o seguem.~\cite{elojs}

\subsubsection{\textit{Callbacks}}
Uma abordagem de programação assíncrona é a adição de um argumento extra, uma função \textit{callback}, nas funções que realizam pedidos lentos.~\cite{elojs} Quando o pedido concluir a função \textit{callback} será chamada tendo como argumento o resultado do pedido. Com o uso de callbacks o nível de indentação aumenta com cada pedido assíncrono o que em alguns casos pode tornar o código um pouco difícil de compreender, principalmente nos casos com múltiplos pedidos assíncronos seguidos que têm de ser sequenciais. Para além disso, qualquer função que chame uma função assíncrona tem de ser ela própria assíncrona. Não é recomendado a reestruturação de grandes quantidades de código através de \textit{callbacks} visto ser mais propenso a erros do que retornar apenas um valor.

\begin{lstlisting}[language=JavaScript, caption=Exemplo de uma \textit{Callback}]
    almocar("comida", function(dentes%*\_*)sujos)%*\{*)
        dentes%*\_*)limpos = lavar%*\_*)dentes(dentes%*\_*)sujos)
    %*\}*))
\end{lstlisting}

\subsubsection{Promessas}
Uma outra abordagem, em vez de passar uma função a ser chamada no futuro, é devolver um objeto que represente este evento futuro, uma promessa. Ou seja, uma promessa é um pedido assíncrono que pode ser concluído no futuro e produzir um valor, tendo a capacidade de notificar qualquer interessado quando o valor estiver disponível.\cite{elojs} O resultado de uma promessa tanto pode já estar pronto ou estar apenas daqui a algum tempo. A principal vantagem das promessas é que simplificam o uso de funções assíncronas visto que não é necessário passar uma função \textit{callback}. Como tal estas funções são similares às restantes mas com uma pequena diferença, o resultado da função pode ainda não estar disponível. 

\begin{lstlisting}[language=JavaScript, caption=Exemplo de uma Promessa]
    almocar("comida")
        .then(dentes%*\_*)sujos =%*$>$*) dentes%*\_*)limpos = lavar%*\_*)dentes(dentes%*\_*)sujos))
\end{lstlisting}

\subsubsection{Exceções}
Durante a execução de um pedido assíncrono podem ocorrer exceções seja por um erro ou porque por exemplo ocorreu um \textit{time out} do pedido, este último acontece essencialmente quando se realiza pedidos através da rede. Estas exceções precisam de ser tratadas por forma a que o programa que estámos a desenvolver não ``expluda'' deixando de funcionar. Esta tratamento não é simples de se realizar quando se usa \textit{callbacks} enquanto que no caso das promessas basta o uso de um \textit{catch}. No caso das \textit{callbacks} o pedido assíncrono teria de devolver dois valores em vez de um, o primeiro com o erro em caso de insucesso e o segundo com o resultado em caso de sucesso o que obrigaria a função \textit{callback} a verificar se não recebeu uma exceção.

\begin{lstlisting}[language=JavaScript, caption=Exemplo de uma \textit{Callback} com captura de exceções]
    almocar("comida", function(erro, dentes%*\_*)sujos)%*\{*)
        if(!erro)%*\{*)
            dentes%*\_*)limpos = lavar%*\_*)dentes(dentes%*\_*)sujos)
        %*\}*)else%*\{*)
            console.log("Falta pasta de dentes")
        %*\}*)
    %*\}*))
\end{lstlisting}

\begin{lstlisting}[language=JavaScript, caption=Exemplo de uma Promessa com captura das exceções]
    almocar("comida")
        .then(dentes%*\_*)sujos =%*$>$*) dentes%*\_*)limpos = lavar%*\_*)dentes(dentes%*\_*)sujos))
        .catch(erro =%*$>$*) console.log("Falta pasta de dentes"))
\end{lstlisting}

\subsubsection{Funções \textit{async}}
Dentro de funções \textit{async} é possível escrever código pseudo-síncrono por forma a descrever código assíncrono com recurso ao \textit{await} que espera pela conclusão de uma promessa antes de avançar com a execução do resto da função, ficando o código com um aspeto semelhante ao síncrono. As funções \textit{async} retornam implicitamente uma promessa e enquanto estão à espera duma promessa (\textit{await}) ficam congeladas. Serão resumidas mais tarde quando a promessa estiver concluída.

\begin{lstlisting}[language=JavaScript, caption=Exemplo de uma função \textit{async}]
    async function almoco()%*\{*)
        try%*\{*)
            dentes%*\_*)sujos = await almocar("comida")
            dentes%*\_*)limpos = lavar%*\_*)dentes(dentes%*\_*)sujos)
        %*\}*)catch(erro)%*\{*)
            console.log("Falta pasta de dentes")
        %*\}*)
        return "Almocei!"
    %*\}*)
\end{lstlisting}

\section{Node.js}

\section{\acrshort{rest}}
\cite{restws}

\section{express}
\cite{wdmongo}
%procurar "semelhantes" para cada um

\section{passport}
%procurar "semelhantes" para cada um

\section{jsonwebtoken}
%package e conceito JWT
%procurar "semelhantes" para cada um

\section{passport-jwt}
%procurar "semelhantes" para cada um

\section{CORS}
%falar da package e do conceito CORS
%procurar "semelhantes" para cada um

\section{axios}
%procurar "semelhantes" para cada um

\section{HTTP Status}

\section{Headers do HTTP}

\section{Autenticação.gov}
\cite{agov}

\section{exceljs}
%procurar "semelhantes" para cada um

\section{MongoDB}
\cite{wdmongo}

\section{mongoose}
%procurar "semelhantes" para cada um

\section{Web Semântica}
\cite{lsparql}

\subsection{RDF}
\cite{lsparql}

\subsection{SPARQL}
\cite{lsparql}

%se calhar referir algumas packages de ligação ao sparql em vez de usar o que criei

\section{GraphDB}
%procurar "semelhantes" para cada um (Neo4j)

\section{Swagger}
%procurar "semelhantes" para cada um

\section{Swagger-UI}

\section{yaml-include}
%procurar "semelhantes" para cada um

\section{swagger-ui-express}
%procurar "semelhantes" para cada um

\section{js-yaml}
%procurar "semelhantes" para cada um

\section{Nginx}
\cite{nginxcook}
%procurar "semelhantes" para cada um

\section{Ontologia}
\cite{bontology}
%conceito

\section{Docker}
\cite{udocker}
%procurar "semelhantes" para cada um

\section{Docker Compose}
\cite{udocker}
%procurar "semelhantes" para cada um

\section{Lista Consolidada}

\section{Tabelas de Seleção}

\section{Cache e Fecho Transitivo}
