Neste capítulo são aprofundadas algumas das soluções anteriormente apresentadas de uma vertente da implementação. Além disso, noutros casos é apresentado o estado final da solução desenvolvida. O objetivo deste capítulo é dar uma melhor perceção do que foi implementado e do seu estado de implementação.

\section{Proteção da \acrshort{api} de dados}

Para proteger as rotas da \acrshort{api} é necessário haver métodos de verificação dos \textit{tokens} com o objetivo de decidir se o utilizador/Chave \acrshort{api} pode aceder a uma determinada rota. Isto é percetível na imagem~\ref{fig:protStrag} onde se destacam 3 \textit{middlewares}, \texttt{isLoggedInKey}, \texttt{isLoggedInUser} e \texttt{checkLevel}. De seguida será apresentado o pseudo-código destes \textit{middlewares}. 

Por forma a validar se uma Chave \acrshort{api} pode aceder a uma determinada rota é executado o \textit{middleware} \texttt{isLoggedInKey}:
\begin{lstlisting}[language=pseudocode, caption=Verificação se um pedido com uma determinada Chave \acrshort{api} pode ser efetuado]
function isLoggedInKey(req, res, next)
    key = getJWTfromHeaderOrQueryString('apikey')

    if key then
        keyBD = getKeyFromMongoDB(key)
        if keyBD then
            res = jwt.verify(key, { algorithms: ["RS256"] }, secretForAPIkey)
            if res != expired then
                if keyBD.active == True then
                    return next()
                else
                    #HTTP status 403
                    return "API Key disabled"
            else
                #HTTP status 401
                return "Unauthorized"
        else
            #HTTP status 401
            return "Unauthorized"
    else
        return isLoggedInUser(req, res, next)
\end{lstlisting}
É importante destacar a chamada da função \texttt{isLoggedInUser} que é executada no caso de não ser detetado uma Chave \acrshort{api} no pedido (na \textit{header} \textit{Authorization} ou na \textit{query string} \texttt{apikey}) e como tal, com essa chamada, tenta-se perceber se afinal foi passado um \textit{token} de um utilizador já que todos os utilizadores conseguem aceder às rotas que as Chaves \acrshort{api} conseguem como já referido.

No seguimento, para validar se um determinado \textit{token} de um utilizador pode aceder a uma determinada rota é executado o \textit{middleware} \texttt{isLoggedInUser}:
\begin{lstlisting}[language=pseudocode, caption=Verificação se um pedido com um determinado \textit{token} de um utilizador registado pode ser efetuado]
JWTstrategy = passport-jwt.Strategy

passport.use("jwt", new JWTstrategy(
    secretOrKey: secret,
    algorithms: ["RS256"],
    jwtFromRequest: getJWTfromHeaderOrQueryString('token')
, (token, done) => done(null, token)))

function isLoggedInUser(req, res, next)
    passport.authenticate("jwt", { session: false }, function (err, user, info)
        if err then
            #HTTP status 401
            return "Unauthorized"
        if !user then
            #HTTP status 401
            return "Unauthorized"
        req.logIn(user, function(err)
            if err then
                #HTTP status 401
                return "Unauthorized"

            next()
        )
    )(req, res, next)
\end{lstlisting}

Os \textit{tokens} tanto das Chaves \acrshort{api} como de \textit{tokens} de utilizadores são obtidos através da utilização de extratores presentes na estratégia \texttt{passport-jwt} do \texttt{passport}. Assim para extrair o \textit{token} da \textit{query string} basta:
\begin{lstlisting}[language=javascript, caption=Extração do \textit{token} da \textit{query string}]
var ExtractJWT = require("passport-jwt").ExtractJwt
token = ExtractJWT.fromUrlQueryParameter("<nome do campo, 'token' ou 'apikey' no caso da CLAV>")
\end{lstlisting}
Já para extrair o \textit{token} da \textit{header} \textit{Authorization} basta:
\begin{lstlisting}[language=javascript, caption=Extração do \textit{token} da \textit{header} \textit{Authorization}]
var ExtractJWT = require("passport-jwt").ExtractJwt
token = ExtractJWT.fromAuthHeaderWithScheme("<palavra antes do token, 'Bearer' no caso dum bearer token, 'token' ou 'apikey' no caso da CLAV>")
\end{lstlisting}

Para verificar se o utilizador registado tem um nível suficiente para aceder a uma rota, depois de se verificar que o utilizador está autenticado (\texttt{isLoggedInUser}), deve-se executar o \textit{middleware} \texttt{checkLevel}:
\begin{lstlisting}[language=pseudocode, caption=Verificação se um utilizador registado tem permissões suficientes para aceder a uma determinada rota]
function checkLevel(clearance)
    return function(req, res, next)
        havePermissions = False

        if clearance is Array then
            if req.user.level in clearance then
                havePermissions = True
        else
            if req.user.level >= clearance then
                havePermissions = True

        if havePermissions then
            return next()
        else
            #HTTP status 403
            return "Without enough permissions"
\end{lstlisting}
Ou seja, a variável \texttt{clearance} poderá ser uma lista de números ou apenas um número. No primeiro caso verifica-se que o nível do utilizador está presente na lista, em caso afirmativo então o utilizador tem permissões para aceder. Já no segundo caso, o utilizador só terá permissões para aceder se o seu nível foi igual ou superior ao \texttt{clearance}.

Com estas três \textit{middlewares} é possível proceder à proteção da \acrshort{api} da \acrshort{clav} garantindo que utilizadores com diferentes níveis de acesso apenas conseguem aceder ao que lhes é permitido.

\subsection{Interface da \acrshort{clav}}

A interface tem vários objetivos, um deles é a disponibilização de várias informações de forma pública. Com a proteção da \acrshort{api} de dados, é obrigatório em quase todas as rotas o uso de uma Chave \acrshort{api} ou de um \textit{token} de utilizador o que impossibilita a disponibilização de dados de forma pública. Para contornar este obstáculo, criou-se uma Chave \acrshort{api} específica para a interface para esta puder realizar pedidos à \acrshort{api}. O único problema agora é, como a interface de cada cliente irá obter a Chave \acrshort{api}?

A solução passa pela criação de uma rota específica na \acrshort{api} de dados (GET \path{/chaves/clavToken}) que caso o \texttt{Origin} do pedido seja uma das interfaces da \acrshort{clav} devolve a Chave \acrshort{api} da \acrshort{clav}. Esta rota internamente, cria a Chave \acrshort{api} caso não exista, renova-a se já tiver expirado e por fim devolve-a. Assim apenas permite-se a obtenção desta Chave \acrshort{api} pelas interfaces (através do cabeçalho \texttt{Origin}) e permite-se disponibilizar na interface de forma aberta várias informações obtidas a partir da \acrshort{api}. A Chave \acrshort{api} na interface é armazenada em \textit{localStorage}. Há uma variável, \texttt{interfaceHosts}, na \acrshort{api} de dados para definir os domínios válidos das interfaces.

Para além da proteção na \acrshort{api} de dados é necessário a proteção na interface com o objetivo de impedir o acesso indevido de utilizadores a certas páginas da interface, naquelas em que não lhe são destinadas por alguma razão bem como aquelas em que um dos pedidos à \acrshort{api} de dados irá falhar por falta de permissões. Para tal, como a interface é criada em \textit{Vue.js} podemos associar a cada rota da interface (página) um meta valor \texttt{levels} com os níveis de quem pode aceder. Estes níveis vão de 0 a 7 e o 0 indica que qualquer pessoa pode aceder (sem proteção ou Chaves \acrshort{api}) e de 1 a 7 são os níveis de utilizadores iguais aos presentes na proteção da \acrshort{api} de dados. Com este meta valor, sempre que a rota da interface muda é verificado se o utilizador pode aceder à rota, ou seja, se tem autenticação (caso necessário) e/ou autorização (caso necessário). Caso não tenha autorização o utilizador é redirecionado para a página inicial da interface e é devolvida uma mensagem de falta de permissões, mantendo o utilizador autenticado. Já no caso de falta de autenticação o utilizador é redirecionado para a página de autenticação e devolve uma mensagem de falta de autenticação tendo como possíveis razões não estar autenticado ou o \textit{token} ter expirado. Convém acrescentar que o \textit{token}, o nome e a entidade do utilizador são armazenados em \textit{localStorage}.

Ainda na interface foram feitas algumas melhorias de segurança e performance na realização dos pedidos à \acrshort{api} de dados. Por forma a evitar com antecedência pedidos que já se sabe que irão falhar por falta de autenticação o que se faz é verificar o \textit{token} antes de efetuar qualquer pedido à \acrshort{api} de dados. Isto é possível porque para gerar os \textit{tokens} são usados pares de chaves pública/privadas. Assim, para realizar esta verificação a interface apenas necessita de ter as chaves públicas. Em termos técnicos foi criado um \textit{plugin} \textit{Vue.js} que acrescenta o método \texttt{request} à \textit{framework} que deve ser usado para efetuar os pedidos à \acrshort{api} de dados, sendo que este método trata de tudo o que é necessário para realizar os pedidos, desde obter o \textit{token} do \textit{localStorage}, colocar o \textit{token} de forma apropriada no pedido a efetuar, bem como trata da verificação do \textit{token} antes de efetuar o pedido. No caso do \textit{token} de um utilizador expirar este é redirecionado para a página de autenticação enquanto que no caso da Chave \acrshort{api} da interface expirar pede de novo a Chave \acrshort{api} à \acrshort{api} pela rota anteriormente referida (GET \path{/chaves/clavToken}). Depois do pedido ser realizado, este método também faz \textit{parse} de parte dos erros, ou seja, quando a resposta do pedido tem \acrshort{http} \textit{status} 401 ou 403 este método redireciona o utilizador e devolve uma mensagem de erro de acordo com o \acrshort{http} \textit{status}. Portanto quando é 401 e o utilizador estava autenticado o utilizador é redirecionado para a página de autenticação com uma mensagem de falta de autenticação. Se for uma Chave \acrshort{api} é redirecionado para a página inicial com uma mensagem de erro para tentar de novo. Já quando é 403, este caso apenas acontece com utilizadores autenticados, o utilizador é redirecionado para a página inicial com uma mensagem de erro de falta de permissões, mantendo o utilizador autenticado. No caso de o \acrshort{http} \textit{status} não ser um destes o erro é devolvido à função que chamou este método. Assim quem desenvolve a interface não precisa de se preocupar com estas situações nem de acrescentar sempre manualmente o \textit{token} ao pedido. Necessitam apenas de enviar os dados referentes ao pedido a efetuar (verbo, caminho, \textit{body}, \textit{query string}, etc) pelo que diminui a ocorrência de erros e facilita a manutenção do código.

Por fim, uma pequena nota, um utilizador estar ou não autenticado na interface depende apenas se o \textit{token} do utilizador ainda se encontra ou não em \textit{localStorage}. Em casos de \acrshort{http} \textit{status} 401 este \textit{token} é eliminado de \textit{localStorage} necessitando o utilizador de voltar a se autenticar para voltar a obter um \textit{token} e colocá-lo em \textit{localStorage}.

\section{Autenticação através de \acrshort{cmd}}

Nesta secção será demonstrado como pode utilizar esta forma de autenticação através da interface da \acrshort{clav}. Para iniciar o processo o utilizador deve aceder a \url{https://clav.dglab.gov.pt/users/autenticacao} e carregar no botão ``Chave Móvel Digital''. Após carregar no botão, o utilizador é redirecionado para o Autenticação.gov onde lhe é apresentada uma página a pedir autorização para a partilha do Nome Completo e do \acrshort{nic} do utilizador com a \acrshort{clav}. O utilizador ao autorizar, aparece-lhe o formulário para a inserção do número de telemóvel e do \acrshort{pin} da \acrshort{cmd}. Após carregar em ``Autenticar'' se os valores estiverem corretos aparecerá o formulário para introduzir o \acrshort{pin} temporário enviado por \acrshort{sms}.

\begin{figure}[H]
\centering
\begin{subfigure}{.32\textwidth}
    \begin{center}
        \includegraphics[width=1\linewidth]{img/CMDauto.png}
    \end{center}
    \caption{Pedido de autorização para partilha de atributos}
\end{subfigure}
\begin{subfigure}{.32\textwidth}
    \begin{center}
        \includegraphics[width=1\linewidth]{img/CMDcreds.png}
    \end{center}
    \caption{Formulário da \acrshort{cmd}}
\end{subfigure}
\begin{subfigure}{.32\textwidth}
    \begin{center}
        \includegraphics[width=1\linewidth]{img/CMDcredTemp.png}
    \end{center}
    \caption{Formulário do \acrshort{pin} temporário da \acrshort{cmd}}
\end{subfigure}
\caption{Autenticação.gov: Processo de autenticação com \acrshort{cmd}}
\end{figure}

Ao fim de carregar em ``Confirmar'' e caso o \acrshort{pin} temporário esteja correto, o utilizador é redirecionado de volta para a \acrshort{clav} onde aparecerá ao utilizador uma de duas hipóteses:
\begin{itemize}
    \item Se o utilizador já se encontra registado na \acrshort{clav} então autentica-se com sucesso:
    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=0.5\textwidth]{img/CMDauthSuc.png}
        \end{center}
        \caption{Utilizador autenticado com sucesso através de \acrshort{cmd}}
    \end{figure}
    \item Se o utilizador ainda não se encontra registado na \acrshort{clav} então não é autenticado na \acrshort{clav}:
    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=0.5\textwidth]{img/CMDnotReg.png}
        \end{center}
        \caption{Mensagem de erro na \acrshort{clav} caso não se encontre registado na \acrshort{clav} mas tenha se autenticado com sucesso no Autenticação.gov}
    \end{figure}
\end{itemize}

Por fim, caso o utilizador cancele algum dos passos de autenticação do Autenticação.gov, se engane em alguma credencial ou aconteça algum erro no Autenticação.gov é redirecionado de volta para a \acrshort{clav} onde lhe é apresentado a seguinte mensagem:

\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.5\textwidth]{img/CMDerror.png}
    \end{center}
    \caption{Mensagem de erro na \acrshort{clav} após falha no Autenticação.gov}
\end{figure}

\section{Documentação da \acrshort{api} da \acrshort{clav}}

A documentação da \acrshort{api} de dados da \acrshort{clav} já se encontra disponível em \url{https://clav-api.dglab.gov.pt/v2/docs}, possuindo uma descrição inicial de como os utilizadores podem obter \textit{tokens} e usar a \acrshort{api} de dados a partir do \textit{Swagger UI}. Esta documentação em cada rota possui uma descrição, \textit{query strings} que podem ser definidas, exemplos de \textit{bodies} quando aplicável, possíveis respostas bem como exemplos de respostas. Além disso, tanto os \textit{bodies} e as respostas quando possuem exemplos possuem também o esquema desse \textit{body}/resposta.

Para experimentar uma rota, é então apenas necessário selecionar uma rota, carregar em \textit{Try it out}, inserir os valores que pretende e carregar em \textit{Execute}. Isto claro sem a autenticação. Com autenticação, após obter o \textit{token} para o usar deve carregar no cadeado aberto, selecionar a forma de colocar o \textit{token} no pedido que pretende: 
\begin{itemize}
    \item para Chaves \acrshort{api}:
    \begin{itemize}
        \item Na \textit{query string}: \texttt{apiKeyQuery}
        \item No cabeçalho \texttt{Authorization}: \texttt{apiKeyAuth}
    \end{itemize}
    \item para Utilizadores:
    \begin{itemize}
        \item Na \textit{query string}: \texttt{userQuery}
        \item No cabeçalho \texttt{Authorization}: \texttt{userAuth}
    \end{itemize}
\end{itemize}
inserir o \textit{token} corretamente (atenção que os casos em que é inserido no cabeçalho \texttt{Authorization} são especiais), carregar em \textit{Authorize} e depois já poderá aceder às rotas. Ao efetuar este passo uma vez, o \textit{Swagger UI} usa o mesmo \textit{token} nas restantes rotas que possui a mesma forma de autenticação não necessitando deste passo nessas (aquelas em que o cadeado se encontra fechado).

\section{Exportação de dados}
Um dos requisitos da \acrshort{api} da \acrshort{clav} é permitir a exportação de Classes, Entidades, Tipologias e Legislações em formato \acrshort{json}, \acrshort{xml} e \acrshort{csv}. Deve também permitir exportar toda a ontologia do projeto nos formatos \acrshort{turtle}, \acrshort{json-ld} e \acrshort{rdf}/\acrshort{xml}.

Para a primeira parte foi necessário desenvolver dois conversores, de \acrshort{json} para \acrshort{xml} e de \acrshort{json} para \acrshort{csv} visto que o \acrshort{json} já é por predefinição devolvido.

\subsection{\acrshort{xml}}
O conversor de \acrshort{json} para \acrshort{xml} criado funciona para qualquer estrutura em \acrshort{json}.

Se por exemplo tivermos o seguinte \acrshort{json} a converter:
\begin{lstlisting}[language=json, caption=\acrshort{json} exemplo a converter, label=exem:json]
{
    "nivel": 2,
    "codigo": "100.10",
    "titulo": "Elaboração de diplomas jurídico-normativos",
    "notasAp": [
        {
            "idNota": "http://jcr.di.uminho.pt/m51-clav#na_c100.10_MRIKl-RBu_2sz5u9FzPqH",
            "nota": "Qualquer despacho com diretrizes gerais e abstratas"
        }
    ],
    "subdivisao4Nivel01Sintetiza02": true,
    "pca": {
        "valores": "",
        "notas": "",
        "justificacao": []
    },
    "df": {
        "valor": "NE",
        "nota": null,
        "justificacao": []
    }
}
\end{lstlisting}

O resultado com este conversor será:
\begin{lstlisting}[language=xml, caption=\acrshort{xml} resultante da conversão do \acrshort{json} presente em~\ref{exem:json}]
<?xml version="1.0" encoding="utf-8"?>
<root>
    <nivel type="number">2</nivel>
    <codigo type="string">100.10</codigo>
    <titulo type="string">Elaboração de diplomas jurídico-normativos</titulo>
    <notasAp type="array">
        <item index="0" type="object">
            <idNota type="string">http://jcr.di.uminho.pt/m51-clav#na_c100.10_MRIKl-RBu_2sz5u9FzPqH</idNota>
            <nota type="string">Qualquer despacho com diretrizes gerais e abstratas</nota>
        </item>
    </notasAp>
    <subdivisao4Nivel01Sintetiza02 type="boolean">true</subdivisao4Nivel01Sintetiza02>
    <pca type="object">
        <valores type="string"></valores>
        <notas type="string"></notas>
        <justificacao type="array">
        </justificacao>
    </pca>
    <df type="object">
        <valor type="string">NE</valor>
        <nota type="object">
        </nota>
        <justificacao type="array">
        </justificacao>
    </df>
</root>
\end{lstlisting}

\subsection{\acrshort{csv}}

Da mesma forma que o \acrshort{xml}, o \acrshort{csv} é convertido sem recurso a uma biblioteca que converta já de si o \acrshort{json} para \acrshort{csv} visto que cada objeto \acrshort{json} a exportar necessita de uma exportação personalizada para \acrshort{csv}. Ao contrário do conversor desenvolvido para \acrshort{xml}, o conversor para \acrshort{csv} não converte qualquer objeto para \acrshort{csv} mas apenas um conjunto restrito de objetos \acrshort{json}.

O conjunto de objetos permitidos é lista de classes, de entidades, de tipologias e de legislações, objeto de classe, de entidade, de tipologia e de legislação e mais algumas estruturas especiais de classes.

Quanto à conversão em si, possui uma estrutura interna durante a conversão. Esta estrutura é uma lista de listas, em que cada lista representa uma linha do \acrshort{csv}. Cada elemento de uma das listas representará uma célula do \acrshort{csv}. A primeira lista será a primeira linha do \acrshort{csv} e como tal possuirá os títulos. As restantes listas serão as linhas seguintes do \acrshort{csv} em que cada elemento possuirá os valores já transformados em \textit{strings} dos campos dos objetos.

Para além desta estrutura interna existe um dicionário que permite agilizar o algoritmo de conversão. Este dicionário possuirá vários dicionários, um por cada objeto (Classe, Entidade, Tipologia e Legislação) em que cada um destes dicionários irá ter como chaves os campos a converter. Para cada um destes campos existe um tuplo em que na primeira posição está presente o título a colocar no \acrshort{csv} referente a este campo e na segunda posição a função de transformação a executar para o valor do campo. Há a presença de três casos especiais:
\begin{itemize}
    \item Quando o valor do campo é uma lista de objetos e pretendemos apenas um dos campos de cada objeto, o valor do campo deve ser \verb|campo_campoDoObjeto| e deve ser usada a função de transformação \verb|map_value(<campoDoObjeto>)|
    \item Quando o valor do campo é um objeto do qual irá resultar vários títulos, na primeira posição do tuplo deve estar presente uma \textit{string} vazia e a função de transformação deve devolver uma lista com duas posições, na primeira com os títulos e na segunda com os valores transformados dos campos
    \item Quando o valor do campo é uma lista de objetos Classe, Entidade, Tipologia ou Legislação a primeira posição do tuplo deve ser \texttt{null} e a função de transformação deve devolver uma lista de listas sem a primeira linha de títulos
\end{itemize}
No caso da conversão de um objeto e consoante a transformação (ou seja, o título do dicionário) a inserção realizada na lista de listas varia:
\begin{itemize}
    \item \verb|título == null|: concatena-se a lista de listas devolvida pela função de transformação à lista de listas
    \item \verb|título == ""|: concatena-se a lista dos elementos da primeira linha devolvida pela função de transformação com os elementos da primeira linha e realiza-se o mesmo para o caso da segunda linha devolvida, concatena-se a segunda linha com a segunda linha
    \item Nos restantes casos protege-se\footnote{colocar valor entre aspas (\texttt{"})} o título presente no dicionário e adiciona-se à primeira lista; para além disso, o valor transformado devolvido pela função de transformação é adicionado já protegido à segunda lista.
\end{itemize}

No caso da conversão de uma lista de objetos, para cada objeto será feita a conversão já apresentada para um objeto, onde depois é ignorada a linha dos títulos em todos os objetos exceto no primeiro objeto da lista onde é mantido os títulos gerados. Ou seja, na primeira linha estará presente os títulos e nas seguintes linhas, em cada linha estará presente os valores de um objeto.

O último passo seja para uma lista ou para um único objeto é transformar a estrutura interna no \acrshort{csv}. Para tal, os elementos de cada lista da lista são juntos de acordo com um separador (neste caso é usado o ponto e vírgula, ``\texttt{;}'') tornando a lista de listas numa lista de \textit{strings}. Por fim, as \textit{strings} desta lista são juntas através da inserção de novas linhas (``\texttt{\textbackslash{}n}'') entre cada \textit{string} gerando o \acrshort{csv} final.

De seguida apresenta-se um exemplo de uma conversão, onde o ficheiro \acrshort{json} a converter é o mesmo usado para exemplificar a conversão de \acrshort{xml} presente em~\ref{exem:json}.

\begin{lstlisting}[language=pseudocode, caption=\acrshort{csv} resultante da conversão do \acrshort{json} presente em~\ref{exem:json}]
"Código";"Título";"Notas de aplicação";"Prazo de conservação administrativa";"Nota ao PCA";"Forma de contagem do PCA";"Sub Forma de contagem do PCA";"Critério PCA";"ProcRefs/LegRefs PCA";"Destino final";"Notas ao DF";"Critério DF";"ProcRefs/LegRefs DF"
"100.10";"Elaboração de diplomas jurídico-normativos";"Qualquer despacho com diretrizes gerais e abstratas";"";"";"";"";"";"";"NE";"";"";""
\end{lstlisting}

\subsection{Exportação na \acrshort{api} de dados}

As conversões de \acrshort{json} para \acrshort{xml} ou \acrshort{csv} são realizadas por um \textit{middleware} após a obtenção dos dados em \acrshort{json}. Ou seja, como já referido apenas após se obter os dados pretendidos é que é feita a conversão para o formato de saída pretendido permitindo assim uma maior facilidade de desenvolvimento.

\subsection{Interface de Exportação}

Para facilitar a exportação dos dados foi criada uma página de exportação na interface da \acrshort{clav}. Esta página permite definir todos os parâmetros tal como através da \acrshort{api} de dados e, adicionalmente, o \textit{enconding} de saída dos ficheiros. Assim esta interface permite exportar Classes, Entidades, Tipologias, Legislações e a Ontologia.

\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.9\textwidth]{img/paginaExportacao.png}
    \end{center}
    \caption{Interface de exportação}
\end{figure}

Esta página de exportação está acessível em \url{https://clav.dglab.gov.pt/exportar}.

\section{Migração de \acrshort{http} para \acrshort{https}}

A partir dos requisitos já enunciados em~\ref{sec:sol_httpsReq} foram criadas duas \textit{scripts} uma para correr antes de iniciar o \textit{Nginx} e outra para correr depois de o \textit{Nginx} iniciar.

A \textit{script} que corre antes de iniciar o \textit{Nginx} instala o \texttt{openssl}, gera o certificado autoassinado e \acrshort{dh} \textit{parameters} para permitir o \textit{boot} do \textit{Nginx}.

Já a \textit{script} que corre após o inicio do \textit{Nginx} realiza o \textit{download} do \texttt{acme.sh}, instala-o, obtém o primeiro certificado para o(s) domínio(s) com o \texttt{acme.sh}, instala o certificado com o \texttt{acme.sh}, gera \acrshort{dh} \textit{parameters} mais fortes e, por fim, reinicia o \textit{Nginx} para que o novo certificado e \acrshort{dh} \textit{parameters} tenham efeito, ou seja, sejam usados pelo \textit{Nginx}.

Quanto à configuração do \textit{Nginx} entre a da \acrshort{api} de dados e a da interface há poucas diferenças. Estas diferenças são que na configuração \textit{Nginx} na \acrshort{api} de dados é encaminhado os pedidos para o servidor em \textit{Node.js} enquanto que na configuração \textit{Nginx} da interface há duas variantes onde só uma é usada:
\begin{itemize}
    \item Apenas serve os ficheiros estáticos da interface
    \item Serve os ficheiros estáticos da interface e reencaminha os pedidos para a \acrshort{api} de dados, aqueles em que o caminho começa em \texttt{/<versão\_api>/} ou é igual a \texttt{/clav.yaml}.
\end{itemize}

Quanto às configurações comuns estas serão apresentadas de seguida, explicando para que servem.

Para cumprir o requisito de redirecionamento dos pedidos de \acrshort{http} para \acrshort{https} é colocado o seguinte bloco de código na configuração:
\begin{lstlisting}[caption=Redirecionamento de \acrshort{http} para \acrshort{https} e validação do domínio na configuração \textit{Nginx}]
  server {
    listen <Porta HTTP>;
    server_name localhost;

    location /.well-known/acme-challenge/ {
      alias /var/www/html/.well-known/acme-challenge/;
    }

    location / {
      return 301 https://$host$request_uri;
    }
  }
\end{lstlisting}
Além disso, permite a validação do controlo do domínio por parte do \textit{Let's Encrypt} visto que este pequeno excerto permite que o \textit{Nginx} receba pedidos em \path{/.well-known/acme-challenge/}, caminho este onde é colocado a resposta de um desafio do \textit{Let's Encrypt}.

Fica assim definido o que se faz quando se recebe um pedido \acrshort{http}. Para os pedidos \acrshort{https} é criado também um bloco \texttt{server} onde é ativado o \acrshort{http}2 e é indicado os ficheiros com o certificado:
\begin{lstlisting}[caption=Certificado na configuração \textit{Nginx}]
  server {
    listen <Porta HTTPS> ssl http2;
    server_name localhost;

    ssl_certificate $CERTS/fullchain.pem;
    ssl_certificate_key $CERTS/key.pem;
    ...
  }
\end{lstlisting}
Depois são adicionadas várias configurações recomendadas~\cite{helmet,letEnA+,dhparams,secExpress,strongSSL,helmetCSP,csp,hsts,hsts2}:
\begin{lstlisting}[caption=Recomendações de segurança na configuração \textit{Nginx}]
  server {
    ...

    #Protocolos SSL permitidos
    ssl_protocols TLSv1.2 TLSv1.3;

    #Ciphers SSL permitidos a usar por ordem de preferência
    ssl_ciphers "EECDH+AESGCM:EDH+AESGCM:ECDHE-RSA-AES128-GCM-SHA256:AES256+EECDH:DHE-RSA-AES128-GCM-SHA256:AES256+EDH:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4";

    #DH parameters mais forte
    ssl_dhparam $CERTS/dhparam.pem;
    #Especifica a curva a usar para os ciphers ECDHE
    ssl_ecdh_curve secp384r1;

    #Ativa stapling
    ssl_stapling on;
    ssl_stapling_verify on;

    #Melhora tolerância quando o endereço de um domínio muda
    resolver 8.8.8.8 8.8.4.4 valid=300s;
    resolver_timeout 5s;

    #Adição de cabeçalhos que melhoram a segurança
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload";
    add_header X-DNS-Prefetch-Control off;
    add_header X-Frame-Options SAMEORIGIN;
    add_header X-Download-Options noopen;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header Content-Security-Policy <Cabeçalho CSP>;
  }
\end{lstlisting}
O valor do cabeçalho \texttt{Content-Security-Policy} varia de acordo se for para a \acrshort{api} de dados ou para a interface. A adição dos cabeçalhos na \acrshort{api} de dados é feita pelo \texttt{helmet} (Ver~\cite{helmet}) no servidor \textit{Node.js} em vez de ser no \textit{Nginx} mas o resultado final é igual ao uso desta configuração.

Por fim, na configuração do \textit{Nginx} é também adicionado fora dos \texttt{servers} a diretiva 
\begin{verbatim}
ssl_prefer_server_ciphers on;
\end{verbatim}
com o objetivo de indicar a preferência de uso dos \textit{ciphers} \acrshort{ssl} do servidor definida na configuração (diretiva \texttt{ssl\_ciphers}) em vez dos \textit{ciphers} do cliente. Ficam assim cumpridas todas as recomendações de segurança e os requisitos apresentados em~\ref{sec:sol_httpsReq}, sendo usado para o \textit{deployment} o \textit{docker} e o \textit{docker-compose}. O \textit{deployment} é explicado mais à frente na secção~\ref{sec:deployNoKong}.

\section{\acrshort{api} Gateway}

Nesta secção irá ser abordada a configuração do \textit{Kong} além do desenvolvimento do Serviço de Auth adicional para a proteção da \acrshort{api} de dados.

\subsection{Serviço de \textit{Auth}}
Este serviço desenvolvido em \textit{Node.js} tem como principal papel a autenticação e autorização dos pedidos efetuados. Além disso, este serviço irá tratar de verificar e gerar \textit{tokens} (\acrshort{jwt}s). Assim, este serviço disponibiliza cinco rotas:
\begin{description}
    \item[POST /auth] Autenticar e Autorizar um pedido. Recebe no \textit{body} o verbo, o caminho, a \textit{query string} e os cabeçalhos do pedido a efetuar para a \acrshort{api} de dados. Como resposta devolve respostas com \textit{\acrshort{http} status} 200 (O pedido pode ser efetuado à \acrshort{api}. Devolve no \textit{body}  a informação contida no \textit{token} se este for enviado no pedido.), 401 (\textit{token} inválido ou pedido sem autenticação para aceder a rota), 403 (Pedido sem autorização para aceder a rota) ou 404 (A rota não existe).

        Para saber quem pode aceder determinada rota, o Serviço de \textit{Auth} possui um dicionário em que cada chave é um verbo \acrshort{http} e em cada verbo existe um dicionário com as vários caminhos desse verbo. A cada caminho é associado um valor que indica quem pode aceder a rota. Este valor é:
        \begin{itemize}
            \item \textbf{-1:} Todos podem aceder
            \item \textbf{0:} Só podem aceder Chaves API autenticadas ou utilizadores autenticados
            \item \textbf{Um número maior que 0:} Só podem aceder utilizadores autenticados com nível igual ou superior ao número
            \item \textbf{Lista de números maiores que 0:} Só podem aceder utilizadores autenticados com nível presente nesta lista
        \end{itemize}
        A ordem dos caminhos em cada verbo é importante visto que as rotas são testadas por ordem e, quando há um \textit{match}, é assumido que é essa a rota do pedido não sendo testado o resto dos caminhos.

        Consoante o valor obtido do dicionário é feita a autenticação e autorização necessária para a rota. Caso não seja obtido um valor, assume-se que a rota não existe na \acrshort{api} de dados.

        Sempre que for acrescentada uma nova rota na \acrshort{api} de dados é necessário adicionar essa neste dicionário com as devidas permissões.
    \item[POST /user/sign] Gerar um \textit{token} para um utilizador. Recebe no \textit{body} do pedido a informação do utilizador e o tempo de expiração a usar para o \textit{token}. Como resposta devolve o \textit{token} gerado.
    \item[POST /user/verify] Verificar um \textit{token} de um utilizador. Recebe no \textit{body} o \textit{token} do utilizador. Como resposta, caso o \textit{token} seja válido, devolve a informação contida no \textit{token}.
    \item[POST /apikey/sign] Gerar um \textit{token} para uma Chave API. Recebe no \textit{body} do pedido a informação da Chave API e o tempo de expiração a usar para o \textit{token}. Como resposta devolve o \textit{token} gerado.
    \item[POST /apikey/verify] Verificar um \textit{token} de uma Chave API. Recebe no \textit{body} o \textit{token} da Chave API. Como resposta, caso o \textit{token} seja válido, devolve a informação contida no \textit{token}.
\end{description}

A necessidade de rotas diferentes para utilizadores e Chaves API deve-se ao facto de serem usadas pares de chave pública/privada diferentes para gerar e verificar os \textit{tokens}. Para esta geração e verificação é usada a mesma biblioteca usada até agora, \textit{jsonwebtoken}. Continua-se também a usar os extratores da biblioteca \textit{passport-jwt} para obter os \textit{tokens} dos pedidos, mas já não se recorre ao \textit{passport} para proceder à autenticação visto não ser necessária.

Com a existência deste serviço, a \acrshort{api} de dados deixou de estar protegida e em casos que necessita de forma excecional a verificação ou a geração de \textit{tokens} recorre à \acrshort{api} do Serviço de \textit{Auth}. Apesar disso continua a ser essencial que a \acrshort{api} de dados saiba quem realizou o pedido. Essa informação será enviada num cabeçalho pelo \textit{Kong} algo que será explicado na próxima secção.

\subsection{\textit{Plugin} \texttt{external-auth}}
Como já referido anteriormente não é possível, usando os \textit{plugins} disponíveis do \textit{Kong}, obter uma proteção semelhante à presente na \acrshort{api} de dados. Para resolver esta situação havia duas hipóteses, criar um \textit{plugin} que trata da autenticação e da autorização ou criar um \textit{plugin} que interceta os pedidos, realiza um pedido a um serviço externo para tratar da autenticação e da autorização, e consoante a resposta deixa ou não o pedido ser realizado. A segunda hipótese foi a escolhida visto que implica a criação de um \textit{plugin} de menores dimensões, que tem de ser desenvolvido em \textit{Lua}, e permite por outro lado aproveitar parte do código de autenticação e autorização presente na \acrshort{api} de dados e usá-lo no serviço externo. Ou seja, é uma abordagem mais rápida e simples para além de que este \textit{plugin} de menores dimensões encontrava-se já em parte desenvolvido\footnote{Ver \url{https://github.com/aunkenlabs/kong-external-auth}} onde foi apenas necessário realizar algumas melhorias como a possibilidade de devolver respostas 403 e 404 entre outras alterações\footnote{Ver \url{https://github.com/jcm300/kong-external-auth}}.

De uma forma mais pormenorizada, quando um pedido é recebido pelo \textit{Kong}, este pedido poderá passar por vários \textit{plugins} de acordo com a configuração usada antes e após ser efetuado o pedido à \acrshort{api} de dados. O \textit{plugin} \texttt{external-auth} se adicionado na configuração é executado antes do pedido ser efetuado à \acrshort{api} de dados. Este \textit{plugin} obtém do pedido o caminho, verbo, \textit{query string} e cabeçalhos e envia-os no \textit{body} para o serviço externo. Quando o \textit{plugin} recebe a resposta do serviço externo, consoante o \textit{\acrshort{http} status}:
\begin{itemize}
    \item 200: Insere no pedido a efetuar à \acrshort{api} de dados o cabeçalho \textit{CLAV-Auth} onde é enviado em formato \textit{string} a resposta do serviço externo
    \item 401: Devolve uma resposta de erro para o utilizador com \textit{\acrshort{http} status} 401
    \item 403: Devolve uma resposta de erro para o utilizador com \textit{\acrshort{http} status} 403
    \item 404: Devolve uma resposta de erro para o utilizador com \textit{\acrshort{http} status} 404
    \item Restantes: Devolve uma resposta de erro para o utilizador com \textit{\acrshort{http} status} 401

\end{itemize}

Portanto quando um pedido possui autenticação e autorização pelo serviço externo, este pedido inclui também um cabeçalho \textit{CLAV-Auth} onde estará presente a informação presente no \textit{token}, seja de um utilizador ou de uma Chave API. Este cabeçalho será interpretado pela \acrshort{api} de dados por forma a esta saber quem realizou o pedido. No caso do cabeçalho não ser enviado, for vazio ou num formato incorreto, a \acrshort{api} de dados irá considerar o pedido foi efetuado por alguém ``Desconhecido''.

\subsection{Configuração \textit{Kong}}
O \textit{Kong} pode ser configurado através de um ficheiro de configuração \texttt{.conf} onde é definido o modo em que executa, possíveis ligações a bases de dados, configurações do \textit{Nginx} entre outros. Contudo não é neste ficheiro que se define o comportamento que o \textit{Kong} efetua quando recebe determinado pedido, apesar de se puder alterar algum comportamento através de configurações do \textit{Nginx}. Para definir o comportamento do \textit{Kong} há três hipóteses. A que foi escolhida, configuração declarativa, permite que o \textit{Kong} execute sem necessitar de uma base de dados para armazenar as configurações visto que as configurações são definidas num ficheiro \acrshort{yaml} ou \acrshort{json} que é carregado para memória. Assim não se sobrecarrega desnecessariamente o servidor que executa o \textit{Kong}.

Para usar este configuração declarativa é necessário no ficheiro de configuração \texttt{.conf} colocar a diretiva \texttt{database} com o valor \texttt{off} e a diretiva \texttt{declarative\_config} com o caminho do ficheiro da configuração declarativa.

Na configuração declarativa são usados vários \textit{plugins} a maioria desenvolvidos pelo \textit{Kong} exceto o \textit{external-auth}. Por predefinição os \textit{plugins} do \textit{Kong} estão disponíveis. Para se puder usar \textit{plugins} externos é necessário indicá-los no ficheiro \textit{.conf} na diretiva \texttt{plugins}. Assim o valor aqui colocado foi \texttt{blunded,external-auth} indicando que se pretende usar os plugins do \textit{Kong} (\texttt{blunded}) e o \textit{external-auth}. Antes de iniciar o \textit{Kong} será depois necessário instalar o \textit{plugin} \textit{external-auth}. No ficheiro \textit{.conf} é também indicado para onde os logs de erro e acesso são enviados sendo os de erro enviados para o \texttt{stderr} e os de acesso para o \texttt{stdout}. Além disso indicasse também em que portas (\acrshort{http} e \acrshort{https}) o \textit{Kong} irá receber os pedidos bem como em que portas está acessível a \acrshort{api} de administrador (como é usada uma configuração declarativa esta \acrshort{api} será apenas de leitura).

O primeiro passo na configuração declarativa foi adicionar o serviço da \acrshort{api} de dados e associar desde logo o \textit{plugin} necessário para a proteção da \acrshort{api} de dados:
\begin{lstlisting}[language=yaml, caption=Configuração declarativa do \textit{Kong}: \acrshort{api} de dados]
services:
  - name: API
    url: ${API_HOST}
    routes:
      - name: TodasRotas
        paths:
          - /
    plugins:
      - name: external-auth
        config:
          url: ${SERVER_AUTH_HOST}
          path: /auth
\end{lstlisting}

Com esta configuração inicial o \textit{Kong} reencaminha todos os pedidos que comecem por \texttt{/} para a \acrshort{api} de dados, usando neste serviço o \textit{plugin} \texttt{external-auth} já descrito. Temos assim uma primeira versão funcional com autenticação e autorização da \acrshort{api} de dados.

Contudo a \acrshort{api} de dados necessita de permitir \acrshort{cors} e para tal é adicionado o \textit{plugin} do \textit{Kong} chamado \texttt{cors}\cite{kongCORS}:
\begin{lstlisting}[language=yaml, caption=Configuração declarativa do \textit{Kong}: \textit{plugin} \texttt{cors}]
services:
  - name: API
    ...
    plugins:
      ...
      - name: cors
        service: API
        config:
          origins:
            - '*'
          methods:
            - GET
            ...
          headers:
            - Accept
            ...
          credentials: true
\end{lstlisting}
Além deste foram adicionados mais 3 \textit{plugins} do \textit{Kong} a este serviço, cada um com objetivos diferentes. O \textit{plugin} \texttt{rate-limiting} por forma a limitar o número de pedidos efetuados a 10 pedidos por segundo por endereço \acrshort{ip}\cite{kongRateLimiting}:
\begin{lstlisting}[language=yaml, caption=Configuração declarativa do \textit{Kong}: \textit{plugin} \texttt{rate-limiting}]
services:
  - name: API
    ...
    plugins:
      ...
      - name: rate-limiting
        config:
          second: 10
          policy: local
\end{lstlisting}
É possível também aplicar este \textit{plugin} a rotas especificas da \acrshort{api} de dados.

Por outro lado, o \textit{plugin} \texttt{proxy-cache} é usado para realizar a \textit{cache} de respostas de pedidos \texttt{text/plain} (texto) ou \texttt{application/json} (\acrshort{json}) com verbos \texttt{GET} e \texttt{HEAD} e \textit{\acrshort{http} status} 200, 301 e 404 por uma hora\cite{kongProxyCache}:
\begin{lstlisting}[language=yaml, caption=Configuração declarativa do \textit{Kong}: \textit{plugin} \texttt{proxy-cache}]
services:
  - name: API
    ...
    plugins:
      ...
      - name: proxy-cache
        config:
          cache_ttl: 3600 #segundos (1h) em cache
          strategy: memory
\end{lstlisting}
Com este \textit{plugin} é possível evitar pedidos recentes à \acrshort{api} de dados iguais bem como acelerar o tempo de resposta dos pedidos que foram recentemente efetuados.

É ainda usado o \textit{plugin} \texttt{response-transformer} por forma a adicionar cabeçalhos na resposta devolvida pela \acrshort{api} de dados. Estes cabeçalhos tem como objetivo melhorar a segurança da \acrshort{api}\cite{kongResponseTransformer}:
\begin{lstlisting}[language=yaml, caption=Configuração declarativa do \textit{Kong}: \textit{plugin} \texttt{response-transformer}]
services:
  - name: API
    ...
    plugins:
      ...
      - name: response-transformer
        config:
          remove:
            headers:
              - strict-transport-security
              ...
              - content-security-policy
          add:
            headers:
              - 'Strict-Transport-Security: max-age=31536000; includeSubDomains; preload'
              ...
              - "Content-Security-Policy: default-src 'none'"
\end{lstlisting}

Este \textit{plugin} possui uma ordem de execução seguinte: remover (\textit{remove}), renomear (\textit{rename}), substituir (\textit{replace}), adicionar (\textit{add}) e acrescentar (\textit{append}).

A adição dos \textit{plugins} (\texttt{cors} e \texttt{request-transformer}) permite assim a remoção da \acrshort{api} de dados das bibliotecas \texttt{cors} e \texttt{helmet} que eram usadas para alcançar os mesmos objetivos para os quais estes \textit{plugins} vão ser usados.

A adição do cabeçalho \texttt{Content-Security-Policy} com o valor \texttt{default-src 'none'} no \textit{plugin} \texttt{request-transformer} impede qualquer conteúdo que não a resposta em si. Contudo a \acrshort{api} de dados possui uma página de documentação na rota \texttt{/<Versão da API>/docs} que irá necessitar de um \texttt{Content-Security-Policy} diferente. 

Para tal, definiu-se uma rota na configuração declarativa associando-a ao serviço da \acrshort{api} de dados mas no qual o \textit{plugin} \texttt{request-tranformer} possui um valor diferente para o cabeçalho \texttt{Content-Security-Policy}. Os outros \textit{plugins} associados ao serviço da \acrshort{api} de dados continuam a ser executados para esta rota mas o \textit{plugin} \texttt{request-tranformer} desse serviço é substituído por este definido na rota:
\begin{lstlisting}[language=yaml, caption=Configuração declarativa do \textit{Kong}: Rota da documentação]
routes:
  - name: docs
    service: API
    strip_path: false
    paths:
      - /$API_VERSION/docs
    methods:
      - GET
    plugins:
      - name: response-transformer
        config:
          remove:
            headers:
              - strict-transport-security
              ...
              - content-security-policy
          add:
            headers:
              - 'Strict-Transport-Security: max-age=31536000; includeSubDomains; preload'
              ...
              - "Content-Security-Policy: default-src 'self' $DOMAINS; img-src 'self' https://validator.swagger.io data: $DOMAINS; style-src 'self' 'unsafe-inline' $DOMAINS; script-src 'self' 'unsafe-inline' $DOMAINS"
\end{lstlisting}

A propriedade \texttt{strip\_path} com valor falso impede que o \textit{Kong} associe (parecido com um \textit{bind}) o caminho \texttt{/<Versão API>/docs} do \textit{Kong} ao caminho \texttt{/} da \acrshort{api} de dados. Assim, quando se faz o pedido a esta rota o pedido que é feito na \acrshort{api} de dados é no caminho \texttt{/<Versão API>/docs} desta. 

Por fim, procedeu-se à configuração do \acrshort{https} no \textit{Kong}. Como se usa os certificados do \textit{Let's Encrpyt} pode-se usar o \textit{plugin} \texttt{acme} do \textit{Kong}\cite{kongACME}:
\begin{lstlisting}[language=yaml, caption=Configuração declarativa do \textit{Kong}: \textit{plugin} \texttt{acme}]
plugins:
  - name: acme
    config:
      account_email: $EMAIL
      domains: $DOMAINS_LIST
      renew_threshold_days: 15
      storage: redis
      storage_config:
        redis:
          auth: "redisPass123"
          port: 6379
          database: 0
          host: $REDIS_HOST
      tos_accepted: true
\end{lstlisting}
Para manter a configuração e os certificados do \textit{plugin} após reunícios do \textit{Kong} usa-se o \textit{Redis} para guardar a configuração bem como os certificados. Convém referir que este \textit{plugin} tem de ser global na configuração declarativa e não associado a um único serviço. Além disso, para permitir a geração dos certificados pelo \textit{Let's Encrypt} é necessário permitir o acesso à rota que começa em \texttt{/.well-known/acme-challenge} para permitir a validação do controlo do domínio. Assim foi adicionado o seguinte serviço à configuração declarativa:
\begin{lstlisting}[language=yaml, caption=Configuração declarativa do \textit{Kong}: Serviço para a geração de certificados \acrshort{tls}]
services:
  - name: acme-dummy
    url: http://127.0.0.1:65535
    routes:
      - name: acme-dummy
        paths:
          - /.well-known/acme-challenge
  - name: API
    ...
\end{lstlisting}
Para ativar também o uso do \textit{plugin} \texttt{acme} é necessário no ficheiro \texttt{.conf} indicar onde estão os certificados confiáveis por forma a ser possível o \textit{Kong} iniciar inicialmente para depois puder obter os certificados do \textit{Let's Encrypt}. Para tal, é indicado na diretiva \texttt{nginx\_proxy\_lua\_ssl\_trusted\_certificate} o valor \texttt{/etc/ssl/certs/ca-certificates.crt} (esta é a localização no caso de uma distribuição Ubuntu, poderá ser diferente noutras distribuições e \acrshort{os}'s). Quando o \textit{Kong} iniciar para acionar a criação do certificado é necessário fazer um pedido ao \textit{Kong} correr o seguinte comando \verb|curl https://<domain> -k|, substituindo \verb|<domain>| pelo domínio da \acrshort{api} de dados.

Além disso, por forma a que quando alguém tente aceder às rotas através de \acrshort{http} seja redirecionado para o \acrshort{https} foi adicionado as seguintes propriedades nas rotas:
\begin{lstlisting}[language=yaml, caption=Configuração declarativa do \textit{Kong}: Serviço para a geração de certificados \acrshort{tls}]
services:
  ...
  - name: API
    ...
    routes:
      - name: TodasRotas
        protocols:
          - https
        https_redirect_status_code: 301
        ...
    ...

routes:
  - name: docs
    ...
    protocols:
      - https
    https_redirect_status_code: 301
    ...
\end{lstlisting}
A propriedade \texttt{protocols} indica que protocolos deverão estar disponíveis na rota e a propriedade \texttt{https\_redirect\_status\_code} indica o \textit{status code} nos casos em que os pedidos são efetuados para o \acrshort{http}. Como este \textit{status code} é 301 os cliente serão redirecionados para o \acrshort{https}.

Por fim, por forma a melhorar a segurança do \acrshort{https} é adicionado no ficheiro de configuração \texttt{.conf} algumas diretivas de configuração do \textit{Nginx}:
\begin{lstlisting}[caption=Configurações do \textit{Nginx} no ficheiro de configuração \texttt{.conf}]
#Indicar que se pretende usar ciphers personalizados
ssl_cipher_suite = custom
#Ciphers permitidos a usar por ordem de preferência
sel_ciphers = EECDH+AESGCM:EDH+AESGCM:ECDHE-RSA-AES128-GCM-SHA256:AES256+EECDH:DHE-RSA-AES128-GCM-SHA256:AES256+EDH:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4

#Protocolos SSL permitidos
nginx_http_ssl_protocols = TLSv1.2 TLSv1.3
#Indicar que se deve preferir os ciphers do servidor em vez do cliente
nginx_http_ssl_prefer_server_ciphers = on

#DH parameters mais forte
nginx_http_ssl_dhparam = /etc/ssl/certs/dhparam.pem

#Especifica a curva a usar para os ciphers ECDHE
nginx_http_ssl_ecdh_curve = secp384r1

#Ativar stapling, infelizmente não funciona porque o plugin acme usado ainda não suporta
nginx_http_ssl_stapling = on
nginx_http_ssl_stapling_verify = on

#Melhorar tolerância quando o endereço de um dominio muda
nginx_http_resolver = 8.8.8.8 8.8.4.4 valid=300s
nginx_http_resolver_timeout = 5s

#Tempo em que pode ser reusada uma sessão
nginx_http_ssl_session_timeout = 1d

#Tempo em que é mantida uma conexão idle a um servidor
nginx_upstream_keepalive_timeout = 65
\end{lstlisting}

Uma pequena nota. As variáveis ambiente (\verb|${var}| ou \verb|$var|) serão substituidas antes de serem usadas pelo \textit{Kong} ao aplicar o comando \texttt{envsubst} ao ficheiro da configuração declarativa.

Convém também referir que, esta versão da \acrshort{api} de dados com \textit{Kong} respeita todos os requisitos enunciados na migração de \acrshort{http} para \acrshort{https} (~\ref{sec:sol_httpsReq}) com o objetivo primordial de melhorar a segurança. Para o \textit{deployment} foi também usado o \textit{docker} e o \textit{docker-compose} e é descrito na secção~\ref{sec:deployKong}

\subsection{Arquitetura}
Na imagem~\ref{fig:apiGatewayArch} apresentou-se uma visão inicial da arquitetura. Apresenta-se de seguida a arquitetura final com \textit{Kong}: 
\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.9\textwidth]{img/apiGatewayArchFinal.png}
    \end{center}
    \caption{Arquitetura desenvolvida com \textit{\acrshort{api} Gateway}}\label{fig:apiGatewayArchFinal}
\end{figure}

\section{Resumo}

Resumindo, foi aprofundado a proteção da \acrshort{api} de dados passando pela proteção da interface e como esta melhora o desempenho da \acrshort{api} de dados e da própria interface. De seguida foi apresentado o processo de autenticação através de \acrlong{cmd} e de que forma pode ser usada a documentação da \acrshort{api} de dados disponível em \url{https://clav-api.dglab.gov.pt/v2/docs}. Passasse de seguida para a exportação de dados na \acrshort{api} dando exemplos das conversões que os conversores realizam. Quanto à migração de \acrshort{http} para \acrshort{https} foi aprofundada a configuração do \textit{Nginx} com várias recomendações de segurança. É por fim, aprofundado o desenvolvimento da proteção \acrshort{api} de dados com \textit{Kong} e a configuração deste.

No próximo capítulo é descrito como se pode realizar a instalação tanto da versão \acrshort{https} sem \textit{Kong} bem como com \textit{Kong}.
